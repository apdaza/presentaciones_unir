<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="estilos/estilos.css">
  </head>
  <body>
    <textarea id="source">
      name: inverse
      layout: true
      class: center, middle, inverse
      ---
      template: inverse
      # Introducción a la ingeniería del software y al modelado
      ***
      ---
      layout: false
      # Introducción a la ingeniería del software y al modelado
      ***

      ## Contenidos
      1. La naturaleza del software
      2. La naturaleza única de las webapps
      3. Ingeniería del software
      4. El proceso del software
      5. La práctica de la ingeniería del software
      6. Mitos del software
      7. Cómo comienza todo
      8. Conceptos orientados a objetos
      9. Introducción a UML
      10. Referencias

      ---
      ![RN](./media/tema01/esquema.png)
      ---
      # 1. La naturaleza del software
      ## Software

      > Conjunto de instrucciones, estructuras de datos e información descriptiva
      
      Las tres principales diferencias que presenta el software respecto al hardware son: 
      - se desarrolla o modifica con intelecto.
      - no se 'desgasta'.
      - se construye para uso individualizado.

      El software tiene grandes dominios de aplicación como: 
      sistemas
      aplicación
      ingeniería
      incrustado
      línea de productos
      aplicaciones web
      inteligencia artificial. 
      
      ---
      # 1. La naturaleza del software
      
      También grandes desafíos como:
      - la computación en un mundo abierto.
      - la construcción de redes.
      - el código fuente abierto.

      El __software heredado__ es el desarrollado en décadas pasadas (años 60, 70, 80), que normalmente se van modificando para adaptarse a las nuevas necesidades tecnológicas o del negocio, que en muchas ocasiones contiene funciones básicas para el negocio de la empresa, pero que también suele caracterizarse por su mala calidad. 
      
      Si este software funciona correctamente y satisface las necesidades del usuario, no habría que tocarlo, pero si requiere adaptación tecnológica o surgen nuevos requisitos funcionales, deberá hacerse reingeniería del sistema heredado.
      
      ---
      # 2. La naturaleza única de las webapps

      Las aplicaciones web presentan características diferenciadoras con el resto del software: 
      - hacen un uso intensivo de las redes.
      - trabajan en __concurrencia__.
      - el __rendimiento__ y la __disponibilidad__ son críticos.
      - están orientadas a datos.
      - el contenido y la estética son muy importantes.
      - están en __evolución continua__ con __plazos cortos__ de desarrollo.
      - es fundamental garantizar su __seguridad__.

      ---
      # 3. Ingeniería del software

      Antes de afrontar un desarrollo software hay que tener en cuenta que se debe entender el problema a resolver previamente, el diseño previo del software es crucial, debe tener alta calidad y un mantenimiento posterior sencillo. Para llevarlo a cabo es necesaria la ingeniería de software.
      
      ![RN](./media/tema01/capas_ingsoftware.png)

      ---
      # 4. El proceso del software

      > _«Un proceso define quién hace qué, cuándo y cómo, para alcanzar cierto objetivo»._ (I. Jacobson, G. Booch y J. Rumbaugh).
      
      La estructura de proceso del software está compuesta por cinco actividades principales que la mayoría de las veces se aplican de forma iterativa:
      
      ![RN](./media/tema01/actividades_proceso.png)

      Estas actividades se complementan por actividades comunes que se aplican a lo largo de todo el proyecto: 
      - seguimiento y control.
      - gestión del riesgo.
      - aseguramiento de la calidad.
      - revisiones técnicas.
      - medición.
      - gestión de la configuración.
      - gestión de la reutilización.
      - preparación y producción del producto del trabajo.

      ---
      # 5. La práctica de la ingeniería del software

      Para resolver un problema en general y también aplicable a la ingeniería de software en particular se debe entender el problema, planificar la solución, ejecutar el plan y examinar el resultado.
      
      Los siete principios de la ingeniería de software, como propuso David Hooker, son:

      ![intermedia](./media/tema01/principios_ingsoftware.png)

      ---
      # 6. Mitos del software

      Los siguientes son falsos mitos del software que hay que evitar, tal como señala Pressman (2010):

      - __Mitos de la administración:__
       - Tenemos un libro lleno de estándares y procedimientos para elaborar software. 
       - Si nos atrasamos, podemos agregar más programadores y ponernos al corriente.
       - Si decido subcontratar el proyecto de software a un tercero, puedo descansar y dejar que esa compañía lo elabore.

      - __Mitos del cliente:__
       - Para comenzar a escribir programas, es suficiente el enunciado general de los objetivos y entraremos en detalles más adelante.
       - Los requisitos del software cambian continuamente, pero el cambio se asimila con facilidad debido a que el software es flexible.
      
      ---
      # 6. Mitos del software

      - __Mitos del profesional:__

       - Una vez escrito el programa y funcionando, nuestro trabajo ha terminado.
       - Hasta que no se ejecute el programa, no hay manera de evaluar su calidad.
       - El único producto resultante del trabajo que se entrega en un proyecto exitoso es el programa que funciona.
       - La ingeniería de software hará que generemos documentación voluminosa e innecesaria, e invariablemente nos retrasará.

      ---
      # 7. Cómo comienza todo

      Los proyectos de software comienzan por la __aparición de una necesidad__: 
      - ampliación de funcionalidades o corrección de defectos en una aplicación existente.
      - adaptar un sistema heredado a un nuevo entorno.
      - la necesidad de crear un nuevo producto/servicio/sistema.
      
      ---
      # 8. Conceptos orientados a objetos

      Un sistema se califica como Orientado-a-Objetos cuando reúne las características de: abstracción, encapsulación, herencia y polimorfismo; y los conceptos básicos que las forman: objetos, mensajes, clases, instancias y métodos.

      ## Conceptos Básicos:
      - Un __objeto__ 
       - Es una encapsulación abstracta de información, junto con los métodos o procedimientos para manipularla. 
       - Contiene operaciones que definen su comportamiento y variables que definen su estado entre las llamadas a las operaciones.
       - Es una instancia concreta de una clase.
      
      - Una __clase__ equivale a la generalización o abstracción de un tipo específico de objetos y es una estructura que encapsula datos (atributos) y operaciones (métodos).
      
      ---
      # 8. Conceptos orientados a objetos
      ## Conceptos Básicos:

      - Un __mensaje__ representa una acción a tomar por un determinado objeto.
      
      - Una __instancia__ es la concrección de una clase.
      
      - Un __método__:
       - Consiste en la implementación en una clase de un protocolo de respuesta a los mensajes dirigidos a los objetos de la misma. 
       - La respuesta a tales mensajes puede incluir el envío por el método de mensajes al propio objeto y aun a otros, también como el cambio del estado interno del objeto.      
      
       En un programa orientado a objetos los diferentes objetos interactúan entre ellos mediante los mensajes, que son llamadas desde uno objeto emisor para que se ejecute el código que contiene un método del objeto receptor.  
      ---
      # 8. Conceptos orientados a objetos

      ## Características

      ![RN](./media/tema01/herencia_polimorfismo.png)
            
      Un buen diseño de una clase debe garantizar el encapsulamiento de sus atributos y métodos, la alta cohesión y el bajo acoplamiento.
      
      ---
      # 8. Conceptos orientados a objetos

      ## Características

      __La abstracción:__
      
      Consiste en la generalización conceptual de un determinado conjunto de objetos y de sus atributos y propiedades, dejando en un segundo término los detalles concretos de cada objeto. 

      __La encapsulación:__
    
      Se refiere a la capacidad de agrupar y condensar en un entorno con límites bien-definidos distintos elementos. Cuando hablemos de encapsulación en general siempre nos referiremos, a encapsulación abstracta. La Clase es una encapsulación porque constituye una cápsula que encierra y amalgama de forma clara tanto los datos de que constan los objetos como los procedimientos que permiten manipularlos. Las Clases se constituyen, así, en abstracciones encapsuladas.

      ---
      # 8. Conceptos orientados a objetos

      ## Características

      __La herencia:__
    
      Se aplica sobre las clases. O sea, de alguna forma las clases pueden tener descendencia, y ésta heredará algunas características de las clases "padres". Si disponemos las clases con un formato de árbol genealógico, tenderemos lo que se denomina una estructura jerarquizada de clases.
      
      Las clases pueden heredar diferencialmente de otras clases (denominadas "superclases") determinadas características, mientras que, a la vez, pueden definir las suyas propias. Tales clases pasan, así, a denominarse "subclases" de aquéllas. 
      
      La herencia se implementa mediante un mecanismo que se denomina derivación de clases: las superclases pasan a llamarse clases base, mientras que las subclases se constituyen en clases derivadas. 
      
      El mecanismo de herencia está fuertemente relacionado con la reutilización del código en OOP. Una clase derivada posibilita, el fácil uso de código ya creado en cualquiera de las clases base ya existentes.

      ---
      # 8. Conceptos orientados a objetos

      ## Características

      __Polimorfismo:__
      
      Sugiere múltiples formas, se refiere a la posibilidad de acceder  a un variado rango de funciones distintas a través del mismo interfaz. En la práctica, un mismo identificador puede tener distintas formas (distintos cuerpos de función, distintos comportamientos) dependiendo, en general, del contexto en el que se halle inserto.
      
      El polimorfismo se puede establecer mediante la __sobrecarga__, la __sobreescritura__ y la __ligadura dinámica__. 
      
      La sobrecarga y la sobrescritura se refieren al uso del mismo identificador u operador en distintos contextos y con distintos significados.
      
      Con la ligadura dinámica, pueden invocarse operaciones en objetos obviando el tipo actual del éstos hasta el momento de la ejecución del código.

      ---
      # 8. Conceptos orientados a objetos

      ## Otros Conceptos
    
      - __Agregación:__ Composición de un objeto por otros. Es una relación más débil que la que existe entre el atributo y el objeto al cual pertenece, y más fuerte que una asociación.
    
      - __Concurrencia:__ Propiedad que distingue un objeto activo de otro inactivo. 
    
      - __Persistencia:__ Es la propiedad de un objeto cuya existencia trasciende el tiempo y/o el espacio (ej. el objeto continua existiendo luego de que su creador deja de existir / la ubicación de un objeto se mueve a un espacio de direcciones diferente de aquella donde fue creada). 
    
      - __Visibilidad:__ capacidad de restringir el acceso a atributos y servicios de un objeto. Particularmente importante en el diseño e implementación. (ej.: público / protegido / privado)

      ---
      # 9. Introducción a UML

      El Lenguaje de Modelado Unificado (UML) es un lenguaje de diseño para modelar software mediante diferentes tipos de diagramas. 
      
      Es un lenguaje de modelado visual que permite mediante representaciones, para los proyectos de software: 

      - __Visualizar:__ permite mediante representaciones gráficas construir modelos que representan el dominio del problema y la solución.

      - __Especificar:__ permite especificar mediante el modelo estático la estructura y mediante el modelo dinámico el comportamiento.

      - __Construir:__ permite mediante el uso de herramientas CASE la generación de código en base a los modelos planteados.

      - __Documentar:__ permite gestionar desde los requerimientos, todos los conjuntos de diagramas, códigos, manuales, etc.
      
      ---
      # 9. Introducción a UML
      
      Los principales diagramas son:

      -	__Diagrama de clases:__ proporciona elementos para modelar las clases (con sus atributos y métodos) y las relaciones y asociaciones entre ellas.

      -	__Diagrama de implementación:__ permite mostrar la distribución física de un sistema software en las plataformas de hardware y entornos de ejecución.

      -	__Diagramas de casos de uso:__ representan la interacción del usuario con las diferentes funciones del sistema.

      -	__Diagramas de secuencia:__ muestra la comunicación dinámica entre los diferentes objetos para llevar a cabo una tarea, describiendo el orden de ejecución.
     
      ---
      # 9. Introducción a UML

      - __Diagramas de comunicación:__ representan como los diagramas de secuencia la comunicación entre los objetos para realizar una tarea, enfatizando en las relaciones entre las clases y objetos.

      - __Diagramas de actividad:__ muestran el comportamiento dinámico del sistema mediante el flujo de control de las acciones que debe realizar.

      - __Diagramas de estado:__ modelan los estados por los que pasa un objeto y las acciones que desencadenan la transición de estados.

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_01.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_02.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_03.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_04.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_05.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_06.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_07.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_08.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_09.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_10.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_11.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_12.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_13.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_14.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_15.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_16.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_17.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_18.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_19.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_20.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_21.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_22.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_23.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_24.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_25.png)

      ---
      # 9. Introducción a UML

      ## Modelo conceptual:

      ![RN](./media/tema01/uml_26.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Cronómetro:__

      El caso práctico elegido para la elaboración de los diagramas de UML es un aplicativo de escritorio que permita al usuario manejar un cronómetro con la implementación normal de las funciones básicas de un elemento como este: avanzar, parar, retroceder, reset.

      ![RN](./media/tema01/uml_ejemplo_01.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de casos de uso:__

      ![RN](./media/tema01/uml_ejemplo_02.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de clases:__

      ![RN](./media/tema01/uml_ejemplo_03.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de estados:__

      ![RN](./media/tema01/uml_ejemplo_04.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de secuencia:__

      ![RN](./media/tema01/uml_ejemplo_05.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de colaboración:__

      ![RN](./media/tema01/uml_ejemplo_06.png)

      ---
      # 9. Introducción a UML

      ## Ejemplo:

      __Diagrama de paquetes:__

      ![RN](./media/tema01/uml_ejemplo_07.png)


      ---
      # 10. Referencias

      Hooker, D. (1996). Seven Principles of Software Development. Recuperado de: http://c2.com/cgi/wiki?SevenPrinciplesOfSoftwareDevelopment 
      
      Jacobson, I., Booch, G., Rumbaugh, J. (2013). El proceso unificado de desarrollo de software. Madrid: Addison Wesley. 
      
      Pressman, R. (2010). Ingeniería del software (7ª ed.). México: McGrawHill.
      


    </textarea>
    <script src="scripts/remark.js"></script>
    <script>
       var slideshow = remark.create();
    </script>
  </body>
</html>
